node单线程支撑高并发原理（node异步I/O）:
众所周知nodejs是单线程且支持高并发的脚本语言。可为什么单线程的nodejs可以支持高并发呢？很多人都不明白其原理，下面我来谈谈我的理解：

1. node的优点：I/O密集型处理是node的强项，因为node的I/O请求都是异步的（如：sql查询请求、文件流操作操作请求、http请求...）
2. node的缺点：不擅长cpu密集型的操作
    a. 什么是cpu密集型操作（复杂的运算、图片的操作）
    b. nodejs为什么不擅长cpu密集型操作
    因为nodejs是单线程的，进行密集型的运算会导致主线程挂起

1、Nodejs是一个平台，构建在chrome的V8上（js语言解释器），采用事件驱动、非阻塞模型（ c++库：libuv）。
2、为什么单线程却能够支持高并发？
    （1）前提：I/O密集型任务
    （2）单线程的解释：主线程一个，底层工作线程多个。
    （3）事件机制的底层依赖库：libuv、libeio、libev

3、单线程的好处：
（1）多线程占用内存高
（2）多线程间切换使得CPU开销大
（3）多线程由内存同步开销
（4）编写单线程程序简单
（5）线程安全
4、单线程的劣势：

（1）CPU密集型任务占用CPU时间长
（2）无法利用CPU的多核
（3）单线程抛出异常使得程序停止

事件驱动/事件循环
1、每个Node.js进程只有一个主线程在执行程序代码，形成一个执行栈（execution context stack)。
2.主线程之外，还维护了一个"事件队列"（Event queue）。当用户的网络请求或者其它的异步操作到来时，node都会把它放到Event Queue之中，此时并不会立即执行它，代码也不会被阻塞，继续往下走，直到主线程代码执行完毕。
3、主线程代码执行完毕完成后，然后通过Event Loop，也就是事件循环机制，开始到Event Queue的开头取出第一个事件，从线程池中分配一个线程去执行这个事件，接下来继续取出第二个事件，再从线程池中分配一个线程去执行，然后第三个，第四个。主线程不断的检查事件队列中是否有未执行的事件，直到事件队列中所有事件都执行完了，此后每当有新的事件加入到事件队列中，都会通知主线程按顺序取出交EventLoop处理。当有事件执行完毕后，会通知主线程，主线程执行回调，线程归还给线程池。
4、主线程不断重复上面的第三步。


(node:15712) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 message listeners added. Use emitter.setMaxListeners() to increase limit